infection <- rep.int(0, nNode)  ### infection status 0 uninfected 1 infected
new_infected <- list()  # to store the ID of nodes being activated each time step
day<-1
day_infected <- 1 ### infected num daily
new_infected[[day]]<-node_seed
node_value[as.numeric(node_seed)] <- 1 ### assign value for seed nodes
infection[as.numeric(node_seed)] <- 1
day<-2
old_infected<-which(infection == 1)
ContagiousID<-which(infection == 1) #nodes that are contagious
activeID<-unlist(lapply(ContagiousID,calculate_value2,each_neighbors,Pprob))
newactiveID<- setdiff(activeID, old_infected)
if (length(activeID)!=0)
{new_infected[[day]]<-newactiveID
infection[as.numeric(newactiveID)] <- 1
}else {new_infected[[day]]<-integer(0)}
day_infected[day] <- sum(infection == 1)
day<-3
old_infected<-which(infection == 1)
ContagiousID<-which(infection == 1) #nodes that are contagious
activeID<-unlist(lapply(ContagiousID,calculate_value2,each_neighbors,Pprob))
newactiveID<- setdiff(activeID, old_infected)
if (length(activeID)!=0)
{new_infected[[day]]<-newactiveID
infection[as.numeric(newactiveID)] <- 1
}else {new_infected[[day]]<-integer(0)}
day_infected[day] <- sum(infection == 1)
for (day in c(4:30)){
old_infected<-which(infection == 1)
Within3days<-list(new_infected[[day-3]],
new_infected[[day-2]],new_infected[[day-1]])
ContagiousID<-unlist(Within3days, use.names = FALSE)
activeID<-unlist(lapply(ContagiousID,calculate_value2,each_neighbors,Pprob))
newactiveID<- setdiff(activeID, old_infected)
if (length(activeID)!=0)
{new_infected[[day]]<-newactiveID
infection[as.numeric(newactiveID)] <- 1
}else {new_infected[[day]]<-integer(0)}
day_infected[day] <- sum(infection == 1)
day=day+1
}
return(day_infected)
}
##### function of IC, to be used multiply according to different seeds (i.e., who in the network get the virus first)
IC2 <- function(i,seeds,nNode,each_neighbors,Pprob) {
day_infected_matrix <- do.call('rbind', lapply(1:i, IC,seeds,nNode,
each_neighbors,Pprob))
return(day_infected_matrix)
}
#  For the orginial network :
# prepare the seed matrix:
#introduce a patient to an otherwise healthy population, this person should be randomly selected to mimic the contagion in real-world
#since we have only 140 nodes, we can selecte them one by one; therefore, we will have 140 different staring points to kick-off the congation procee
seeds<-c(1:140)
nNode=140  #size of the original network
Pprob=0.1  #the probability for an infected person to pass down the virus to his/her neighbours
adj_matrix <- igraph::as_adjacency_matrix(class2022, type = 'both')
each_neighbors <- which(adj_matrix > 0, arr.ind = TRUE)
each_neighbors <- split(each_neighbors[, 2], each_neighbors[, 1]) #get the neigbhour list of each node
result3<- replicate(100, IC2(140,seeds,nNode,each_neighbors,Pprob), simplify=FALSE)  #run at least 100 times since each IC model run has its own randomness (see the "calculate_value2 function")
each_neighbors <- which(adj_matrix > 0, arr.ind = TRUE)
each_neighbors <- split(each_neighbors[, 2], each_neighbors[, 1]) #get the neigbhour list of each node
threshold_model<-function(max_steps,node_seeds,n_nodes,each_neighbors,thresh){
infection_status <- rep.int(0, n_nodes)
day <- 0L
daily_infected <- 0
day<-1L
newly_infected <- node_seeds
infection_status[newly_infected] <- 1
daily_infected[2] <- sum(infection_status == 1)
while((day<max_steps)&(length(newly_infected) != 0)){
day <- day + 1
not_infected <- which(infection_status == 0)
newly_infected <- vector()
for(node in not_infected){
infected_neighbours <- mean(infection_status[each_neighbors[[node]]])
if(infected_neighbours > thresh[node]){
newly_infected <- append(newly_infected, node)
}
}
infection_status[newly_infected] <- 1
daily_infected[day+1] <- sum(infection_status == 1)
}
return(daily_infected)
}
# compute the list of neighbors for each node
adj_matrix <- igraph::as_adjacency_matrix(class2022, type = 'both')
each_neighbors <- which(adj_matrix > 0, arr.ind = TRUE)
each_neighbors <- split(each_neighbors[, 2], each_neighbors[, 1])
# set the other parameters
max_steps <- 100L
n_nodes <- 140L
n_attempts <- 20L
thresh <- class2022_att$tRecipe
# run the model to check for the best node
max_infected <- vector(length = n_nodes)
n_steps <- vector(length = n_nodes)
for(seed in 1:n_nodes){
node_history <- threshold_model(max_steps,seed,n_nodes,each_neighbors,thresh)
max_infected[seed] <- tail(node_history, n = 1L)
n_steps[seed] <- length(node_history)
}
library(visNetwork)
library(htmlwidgets)
library(igraph)
library(dplyr)
library(ggplot2)
class2022<-readRDS("classnetwork_2022.rds")
class2022_att<-readRDS("class2022_attributes.rds")
class2022_matrix<-as_edgelist(class2022, names = TRUE)
nodes <- data.frame(id = 1:140)
edges <- data.frame(from = class2022_matrix[,1],
to = class2022_matrix[,2])
saveWidget(visNetwork(nodes, edges) %>%
visIgraphLayout(layout = "layout_nicely",smooth =  TRUE) %>%
visNodes(shape="circle") %>%
visOptions(highlightNearest = list(enabled = T, hover = T),
nodesIdSelection = T), file = "class2022.html")
threshold_model<-function(max_steps,node_seeds,n_nodes,each_neighbors,thresh){
infection_status <- rep.int(0, n_nodes)
day <- 0L
daily_infected <- 0
day<-1L
newly_infected <- node_seeds
infection_status[newly_infected] <- 1
daily_infected[2] <- sum(infection_status == 1)
while((day<max_steps)&(length(newly_infected) != 0)){
day <- day + 1
not_infected <- which(infection_status == 0)
newly_infected <- vector()
for(node in not_infected){
infected_neighbours <- mean(infection_status[each_neighbors[[node]]])
if(infected_neighbours > thresh[node]){
newly_infected <- append(newly_infected, node)
}
}
infection_status[newly_infected] <- 1
daily_infected[day+1] <- sum(infection_status == 1)
}
return(daily_infected)
}
# compute the list of neighbors for each node
adj_matrix <- igraph::as_adjacency_matrix(class2022, type = 'both')
each_neighbors <- which(adj_matrix > 0, arr.ind = TRUE)
each_neighbors <- split(each_neighbors[, 2], each_neighbors[, 1])
# set the other parameters
max_steps <- 100L
n_nodes <- 140L
n_attempts <- 20L
thresh <- class2022_att$tRecipe
# run the model to check for the best node
max_infected <- vector(length = n_nodes)
n_steps <- vector(length = n_nodes)
for(seed in 1:n_nodes){
node_history <- threshold_model(max_steps,seed,n_nodes,each_neighbors,thresh)
max_infected[seed] <- tail(node_history, n = 1L)
n_steps[seed] <- length(node_history)
}
summary <- data.frame("node" = 1:n_nodes, "max_infected" = max_infected,
"n_steps" = n_steps)
head(summary[with(summary, order(-max_infected, n_steps)),], 3)
threshold_model<-function(max_steps,node_seeds,n_nodes,each_neighbors,thresh){
infection_status <- rep.int(0, n_nodes)
day <- 0L
daily_infected <- 0
day<-1L
newly_infected <- node_seeds
infection_status[newly_infected] <- 1
daily_infected[2] <- sum(infection_status == 1)
while((day<max_steps)&(length(newly_infected) != 0)){
day <- day + 1
not_infected <- which(infection_status == 0)
newly_infected <- vector()
for(node in not_infected){
infected_neighbours <- mean(infection_status[each_neighbors[[node]]])
if(infected_neighbours > thresh[node]){
newly_infected <- append(newly_infected, node)
}
}
infection_status[newly_infected] <- 1
daily_infected[day+1] <- sum(infection_status == 1)
}
return(daily_infected)
}
# compute the list of neighbors for each node
adj_matrix <- igraph::as_adjacency_matrix(class2022, type = 'both')
each_neighbors <- which(adj_matrix > 0, arr.ind = TRUE)
each_neighbors <- split(each_neighbors[, 2], each_neighbors[, 1])
# set the other parameters
max_steps <- 100L
n_nodes <- 140L
n_attempts <- 20L
thresh <- class2022_att$tRecipe
# run the model to check for the best node
max_infected <- vector(length = n_nodes)
n_steps <- vector(length = n_nodes)
for(seed in 1:n_nodes){
node_history <- threshold_model(max_steps,seed,n_nodes,each_neighbors,thresh)
max_infected[seed] <- tail(node_history, n = 1L)
n_steps[seed] <- length(node_history)
}
summary <- data.frame("node" = 1:n_nodes, "max_infected" = max_infected,
"n_steps" = n_steps)
head(summary[with(summary, order(-max_infected, n_steps)),], 3)
threshold_model<-function(max_steps,node_seeds,n_nodes,each_neighbors,thresh){
infection_status <- rep.int(0, n_nodes)
day <- 0L
daily_infected <- 0
day<-1L
newly_infected <- node_seeds
infection_status[newly_infected] <- 1
daily_infected[2] <- sum(infection_status == 1)
while((day<max_steps)&(length(newly_infected) != 0)){
day <- day + 1
not_infected <- which(infection_status == 0)
newly_infected <- vector()
for(node in not_infected){
infected_neighbours <- mean(infection_status[each_neighbors[[node]]])
if(infected_neighbours > thresh[node]){
newly_infected <- append(newly_infected, node)
}
}
infection_status[newly_infected] <- 1
daily_infected[day+1] <- sum(infection_status == 1)
}
return(daily_infected)
}
# compute the list of neighbors for each node
adj_matrix <- igraph::as_adjacency_matrix(class2022, type = 'both')
each_neighbors <- which(adj_matrix > 0, arr.ind = TRUE)
each_neighbors <- split(each_neighbors[, 2], each_neighbors[, 1])
# set the other parameters
max_steps <- 100L
n_nodes <- 140L
n_attempts <- 20L
thresh <- class2022_att$tRecipe
# run the model to check for the best node
max_infected <- vector(length = n_nodes)
n_steps <- vector(length = n_nodes)
for(seed in 1:n_nodes){
node_history <- threshold_model(max_steps,seed,n_nodes,each_neighbors,thresh)
max_infected[seed] <- tail(node_history, n = 1L)
n_steps[seed] <- length(node_history)
}
summary <- data.frame("node" = 1:n_nodes, "max_infected" = max_infected,
"n_steps" = n_steps)
head(summary[with(summary, order(-max_infected, n_steps)),], 3)
class2022_att[138,]
class2022[138,]
degree[class2022,v=138]
degree(class2022,v=138)
betweenness(class2022,v=138)
transitivity(class2022,v=138)
betweenness(class2022,v=138)
degree(class2022, v=138)
betweenness(class2022, v=138)
betweenness(class2022)
max(betweenness(class2022))
#define the IC model
IC_modified<-function(max_steps,node_seeds,n_nodes,each_neighbors,prob){
infection_status <- rep.int(0, n_nodes)
day <- 0
daily_infected <- 0
day<-1
daily_infected[2] <- length(node_seeds)
infection_status[as.numeric(node_seeds)] <- 1
while((day<max_steps)&(tail(daily_infected, 1)<n_nodes)){
day <- day + 1
old_infected <- which(infection_status == 1)
for(node in old_infected){
new_infected <- each_neighbors[[node]][which(runif(length(each_neighbors[[node]]))<=prob[node])]
infection_status[as.numeric(new_infected)] <- 1
}
daily_infected[day+1] <- sum(infection_status == 1)
}
return(daily_infected)
}
# compute the list of neighbors for each node
adj_matrix <- igraph::as_adjacency_matrix(class2022, type = 'both')
each_neighbors <- which(adj_matrix > 0, arr.ind = TRUE)
each_neighbors <- split(each_neighbors[, 2], each_neighbors[, 1])
# import attribute data
attributes <- readRDS('data/class2022_attributes.rds')
#define the IC model
IC_modified<-function(max_steps,node_seeds,n_nodes,each_neighbors,prob){
infection_status <- rep.int(0, n_nodes)
day <- 0
daily_infected <- 0
day<-1
daily_infected[2] <- length(node_seeds)
infection_status[as.numeric(node_seeds)] <- 1
while((day<max_steps)&(tail(daily_infected, 1)<n_nodes)){
day <- day + 1
old_infected <- which(infection_status == 1)
for(node in old_infected){
new_infected <- each_neighbors[[node]][which(runif(length(each_neighbors[[node]]))<=prob[node])]
infection_status[as.numeric(new_infected)] <- 1
}
daily_infected[day+1] <- sum(infection_status == 1)
}
return(daily_infected)
}
# compute the list of neighbors for each node
adj_matrix <- igraph::as_adjacency_matrix(class2022, type = 'both')
each_neighbors <- which(adj_matrix > 0, arr.ind = TRUE)
each_neighbors <- split(each_neighbors[, 2], each_neighbors[, 1])
# set the other parameters
max_steps <- 500L
n_nodes <- 140L
n_attempts <- 50L
prob <- class2022_att$pYoutube
# perform the IC model several times to decide best starting node
mean_steps <- vector(length = n_nodes)
for(seed in 1:n_nodes){
n_steps <- vector(length = n_attempts)
for(i in 1:n_attempts){
node_history <- IC_modified(max_steps, seed, n_nodes, each_neighbors, prob)
n_steps[i] <- length(node_history)
}
mean_steps[seed] <- mean(n_steps)
}
chosen_node <- which.min(mean_steps)
chosen_node
daily_affected
node_history
node_history[2]
#define the IC model
IC_modified<-function(max_steps,node_seeds,n_nodes,each_neighbors,prob){
infection_status <- rep.int(0, n_nodes)
day <- 0
daily_infected <- 0
day<-1
daily_infected[2] <- length(node_seeds)
infection_status[as.numeric(node_seeds)] <- 1
while((day<max_steps)&(tail(daily_infected, 1)<n_nodes)){
day <- day + 1
old_infected <- which(infection_status == 1)
for(node in old_infected){
new_infected <- each_neighbors[[node]][which(runif(length(each_neighbors[[node]]))<=prob[node])]
infection_status[as.numeric(new_infected)] <- 1
}
daily_infected[day+1] <- sum(infection_status == 1)
}
return(daily_infected)
}
# compute the list of neighbors for each node
adj_matrix <- igraph::as_adjacency_matrix(class2022, type = 'both')
each_neighbors <- which(adj_matrix > 0, arr.ind = TRUE)
each_neighbors <- split(each_neighbors[, 2], each_neighbors[, 1])
# set the other parameters
max_steps <- 500L
n_nodes <- 140L
n_attempts <- 50L
prob <- class2022_att$pYoutube
# perform the IC model several times to decide best starting node
mean_steps <- vector(length = n_nodes)
for(seed in 1:n_nodes){
n_steps <- vector(length = n_attempts)
for(i in 1:n_attempts){
node_history <- IC_modified(max_steps, seed, n_nodes, each_neighbors, prob)
n_steps[i] <- length(node_history)
}
mean_steps[seed] <- mean(n_steps)
}
chosen_node <- which.min(mean_steps)
chosen_node
deg <- degree(class2022, mode = "all")
btw <- betweenness(class2022, directed = FALSE)
cat("*** Chosen node ***\nDegree:", deg[chosen_node], "\nBetweenness:",
btw[chosen_node], "\nProbability to share:", prob[chosen_node])
# Plot the histograms for each measure.
par(mfrow=c(3,1))
hist(deg)
hist(btw)
hist(prob)
# Plot the histograms for each measure.
par(mfrow=c(3,1))
hist(deg)
hist(btw)
hist(prob)
class2022<-readRDS("classnetwork_2022.rds")
copycat2<-class2022
S<-{}
for (k in c(1:5)){
avg_shortest_path=mean_distance(copycat2)
len=length(class2022[1])-length(S)
paths_topick_themax<-{}
for (i in c(1:len)) {
copycat<-copycat2
copycat<-delete.vertices(copycat,i)
avg_new_path=mean_distance(copycat)
paths_topick_themax<-append(paths_topick_themax,
(avg_new_path-avg_shortest_path))
}
sorted_paths<-sort(paths_topick_themax,decreasing=TRUE,index.return=TRUE)
chosen_vertex<-sorted_paths$ix[1]
S<-append(S,chosen_vertex)
copycat2<-delete.vertices(copycat2,chosen_vertex)
}
S
deg<-degree(class2022)
deg<-sort(deg,decreasing=TRUE,index.return=TRUE)
head(deg$ix,5)
bet<-betweenness(class2022)
bet<-sort(bet,decreasing=TRUE,index.return=TRUE)
head(bet$ix,5)
seed<-c(20,71,80,106,2)
#Degree & Betweenness
max_steps <- 100L
n_nodes <- 140L
n_attempts <- 20L
seed<-c(20,71,80,106,2)
thresh <- class2022_att$tRecipe
node_history <- threshold_model(max_steps,seed,n_nodes,each_neighbors,thresh)
max_infected[seed] <- tail(node_history, n = 1L)
n_steps[seed] <- length(node_history)
length(node_history)
#Degree & Betweenness
max_steps <- 100L
n_nodes <- 140L
n_attempts <- 20L
seed<-c(20,71,80,106,2)
thresh <- class2022_att$tRecipe
node_history <- threshold_model(max_steps,seed,n_nodes,each_neighbors,thresh)
tail(node_history, n = 1L)
length(node_history)
print("Total number of infected people:",tail(node_history, n = 1L),"\,")
print("Total number of infected people:",tail(node_history, n = 1L),"\n")
print("Total number of infected people:",tail(node_history, n = 1L),"\n")
print("Total number of infected people:"+tail(node_history, n = 1L)+"\n")
cat("Total number of infected people: ", tail(node_history, n = 1L),"\n")
cat("Duration of spread:",length(node_history))
cat("Total number of infected people: ", tail(node_history, n = 1L),"\n")
cat("Duration of spread:",length(node_history))
#Degree & Betweenness
max_steps <- 100L
n_nodes <- 140L
n_attempts <- 20L
seed<-c(20,71,80,106,2)
thresh <- class2022_att$tRecipe
node_history <- threshold_model(max_steps,seed,n_nodes,each_neighbors,thresh)
cat("Total number of infected people: ", tail(node_history, n = 1L),"\n")
cat("Duration of spread:",length(node_history))
# Greedy algorithm
seed<-c(20,70,78,101,114)
thresh <- class2022_att$tRecipe
node_history <- threshold_model(max_steps,seed,n_nodes,each_neighbors,thresh)
cat("Total number of infected people: ", tail(node_history, n = 1L),"\n")
cat("Duration of spread:",length(node_history))
#Degree & Betweenness
max_steps <- 100L
n_nodes <- 140L
n_attempts <- 20L
seed<-c(20,71,80,106,2)
thresh <- class2022_att$tRecipe
node_history <- threshold_model(max_steps,seed,n_nodes,each_neighbors,thresh)
cat("For degree/betweenness heuristics nodes:\n")
cat("Total number of infected people: ", tail(node_history, n = 1L),"\n")
cat("Duration of spread:",length(node_history),"\n")
# Greedy algorithm
seed<-c(20,70,78,101,114)
thresh <- class2022_att$tRecipe
node_history <- threshold_model(max_steps,seed,n_nodes,each_neighbors,thresh)
cat("\n For Greedy algorithm nodes:\n")
cat("Total number of infected people: ", tail(node_history, n = 1L),"\n")
cat("Duration of spread:",length(node_history))
#Degree & Betweenness
max_steps <- 100L
n_nodes <- 140L
n_attempts <- 20L
seed<-c(20,71,80)
thresh <- class2022_att$tRecipe
node_history <- threshold_model(max_steps,seed,n_nodes,each_neighbors,thresh)
cat("For degree/betweenness heuristics nodes:\n")
cat("Total number of infected people: ", tail(node_history, n = 1L),"\n")
cat("Duration of spread:",length(node_history),"\n")
# Greedy algorithm
seed<-c(20,70,78)
thresh <- class2022_att$tRecipe
node_history <- threshold_model(max_steps,seed,n_nodes,each_neighbors,thresh)
cat("\n For Greedy algorithm nodes:\n")
cat("Total number of infected people: ", tail(node_history, n = 1L),"\n")
cat("Duration of spread:",length(node_history))
degree(class2022,v=c(20,70,78,101,114))
betweenness(class2022,v=c(20,70,78,101,114))
cat("Greedy algorithm nodes attributes")
degree(class2022,v=c(20,70,78,101,114))
betweenness(class2022,v=c(20,70,78,101,114))
transitivity(class2022,v=c(20,70,78,101,114))
cat("Degree/Betweenness nodes attributes")
degree(class2022,v=c(20,71,80,106,2))
betweenness(class2022,v=c(20,71,80,106,2))
transitivity(class2022,v=c(20,71,80,106,2))
cat("Greedy algorithm nodes attributes\n")
degree(class2022,v=c(20,70,78,101,114))
betweenness(class2022,v=c(20,70,78,101,114))
transitivity(class2022,v=c(20,70,78,101,114))
cat("Degree/Betweenness nodes attributes\n")
degree(class2022,v=c(20,71,80,106,2))
betweenness(class2022,v=c(20,71,80,106,2))
transitivity(class2022,v=c(20,71,80,106,2))
class2022_att[,[20,70,78,101,114]]
class2022_att[,c(20,70,78,101,114)]
class2022_att[c(20,70,78,101,114),]
cat("Greedy algorithm nodes attributes\n")
degree(class2022,v=c(20,70,78,101,114))
betweenness(class2022,v=c(20,70,78,101,114))
class2022_att[c(20,70,78,101,114),]
cat("Degree/Betweenness nodes attributes\n")
degree(class2022,v=c(20,71,80,106,2))
betweenness(class2022,v=c(20,71,80,106,2))
class2022_att[c(20,71,80,106,2),]
